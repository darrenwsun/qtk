feature Fix a table based on a good partition.

  before each
    import "db";
    import "tbl";
    .qutils.hdbRoot:"/tmp/hdb_fixTable";
    Table:([] c1:10b; c2:1 2);
    (hsym `$.qutils.hdbRoot,"/2022.01.01/Table/") set Table;
    (hsym `$.qutils.hdbRoot,"/2022.01.02/Table/") set Table;
    system "l ",.qutils.hdbRoot;
    `PlainTable set ([] c1:1 2);

  after each
    system "rm -rf ",.qutils.hdbRoot;

  should add `.d` file if it's missing.
    expect `.d` file added if it's missing.
      .qtk.os.remove .qutils.hdbRoot,"/2022.01.02/Table/.d";
      .qtk.db.fixTable[`Table; 2022.01.01];
      .qtk.db.reload[];
      .qu.compare[select c1, c2 from Table where date=2022.01.02; ([] c1:10b; c2:1 2)]

  should add missing columns in `.d` file while its data file doesn't exist
    expect missing columns added.
      tablePath:.Q.par[`:.; 2022.01.02; `Table];
      .qtk.tbl._deleteColumn[tablePath; `c2];
      .qtk.db.reload[];

      .qtk.db.fixTable[`Table; 2022.01.01];
      .qtk.db.reload[];
      .qu.compare[select c2 from Table where date=2022.01.02; ([] c2:0N 0N)]

  should add missing columns in `.d` file while its data file exists and is compliant
    expect missing columns added.
      tablePath:.Q.par[`:.; 2022.01.02; `Table];
      .qtk.tbl._deleteColumnHeader[tablePath; `c2];
      .qtk.db.reload[];

      .qtk.db.fixTable[`Table; 2022.01.01];
      .qtk.db.reload[];
      .qu.compare[select c2 from Table where date=2022.01.02; ([] c2:1 2)]

  should remove excessive columns in `.d` file while keeping their data file
    expect excessive column headers removed.
      tablePath:.Q.par[`:.; 2022.01.02; `Table];
      .qtk.tbl._addColumn[tablePath; `c3; 0];
      .qtk.db.reload[];

      .qtk.db.fixTable[`Table; 2022.01.01];
      .qtk.db.reload[];
      .qu.compare[.qtk.db._getColumns tablePath; `c1`c2] and
        .qu.compare[.qtk.os.path.isFile .Q.dd[tablePath; `c3]; 1b]

  should put columns in right order
    expect out-of-order columns to be reordered.
      tablePath:.Q.par[`:.; 2022.01.02; `Table];
      @[tablePath; `.d; :; reverse tablePath `.d];
      .qtk.db.reload[];

      .qtk.db.fixTable[`Table; 2022.01.01];
      .qtk.db.reload[];
      .qu.compare[.qtk.db._getColumns[tablePath]; `c1`c2]

  should raise error "TableTypeError: not a partitioned table [*]" if the table is not a partitioned table.
    expect error "TableTypeError: not a partitioned table [*]" if the table is not a partitioned table.
      .qu.compare[
        @[.qtk.db.fixTable[`PlainTable; ]; 2022.01.01; {x}];
        "TableTypeError: not a partitioned table [PlainTable]"]
